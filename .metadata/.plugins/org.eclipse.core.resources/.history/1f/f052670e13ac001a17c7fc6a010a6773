import java.util.ArrayList;
import java.util.*;
import static java.lang.Math.floor;

/**
 * This is a class that models a linked list of integers. This was built to solve the problems around 
 * linked list in Cracking the Coding Interview book;
 * @author chinmaydevadhar
 *
 */
public class Node {
	/**
	 * The data we are storing at the current node
	 */
	int value;
	/**
	 * Pointer to the next node.
	 */
	Node next;
	
	public Node(int value) {
		this.value = value;
	}

	/**
	 * Adds a value to the tail of a linked list. 
	 * @param value the data that we are trying to add to the linked list
	 */
	public void addToTail(int value) {
		Node end = new Node(value);
		Node n = this;
		while (n.next != null) {
			n = n.next;
		}
		n.next = end;
	}
	/**
	 * Prints a linked list given a head node;
	 * @param currentNode
	 */
	private static void displayList(Node currentNode) {
		while (currentNode != null) {
			System.out.print(currentNode.value + " ");
			currentNode = currentNode.next;
		}
		System.out.println("------");
	}
	
	/**
	 * Deletes first node that has contains a specific value or key.
	 * @param head
	 * @param key
	 * @return
	 */
	public Node deleteNode(Node head, int key) {
		Node n = head;
		if (n.value == key) {
			return head.next;
		}
		while(n.next!= null) {
			if (n.next.value == key) {
				n.next = n.next.next;
				return head;
			}
			n = n.next;
		}
		return head;
	}
	
	/**
	 * Deletes all nodes with duplicate values of previous nodes.
	 */
	public Node deleteDuplicates(Node head) {
		Node current = head;
		ArrayList<Integer> alreadySeen = new ArrayList<Integer>();
		alreadySeen.add(head.value);
		while(current.next !=null) {
			System.out.println("**** n.val=" + current.value);
			if (current.next != null) System.out.println("**** n.next.val=" + current.next.value);
			else System.out.println("**** n.next.val=" + current.next);

			if (alreadySeen.contains(current.next.value)) {
				System.out.println("***** Already seen value : " + current.next.value);
				current.next = current.next.next;
			}
			else {
				System.out.println("***** New value : " + current.next.value);
				alreadySeen.add(current.next.value);
				current = current.next;
			}
		}
		return head;

	}
	
	/**
	 * Finds the element at a distance of 'numtoLast' from the end.
	 * Makes a copy of the linked list and reverses it.
	 * Returns the element.
	 * @param numtolast
	 * @param head
	 * @return
	 */
	public int getElement(int numtolast, Node head) {
		Node current  = head;
		ArrayList <Integer> values = new ArrayList<Integer>();
		values.add(head.value);
		while(current.next != null) {
			values.add(current.next.value);
			current = current.next;
		}
		Collections.reverse(values);
		
		int returnval = values.get(numtolast-1);
		return returnval;
	}
	
	/**
	 * Finds and returns the element that is a distance of 'numtoLast' from the end without a temporary buffer.
	 */
	public int getElementFromLast(int numtolast, Node head) {
		Node current  = head;
		int count = 0;
		while(current.next!=null) {
			count +=1;
			current = current.next;
		}
		current = head;
		for (int i = 0; i < count - numtolast + 1 ; i++) 
            current = current.next; 
  
        return current.value; 
		
	}
	
	/**
	 * Deletes a node from the middle of a linked list when only given access to that node.
	 */
	public void deleteFromMiddle(Node c) {
		c.value = c.next.value;
		c.next = c.next.next;
	}
	
	/**
	 * Partitions a linked list around a value x with smaller values to the left of x and larger or equal values to the right.
	 */
	public Node partitionList(Node head, int x) {
		Node current  = head;
		ArrayList<Integer> smallerValues = new ArrayList<>();
		ArrayList<Integer> largerValues = new ArrayList<>();
				while (current.next != null) {
			if (current.next.value < x)
				smallerValues.add(current.next.value);
			else {
				largerValues.add(current.next.value);
			}
			current = current.next;
		}
		Node head2 = new Node(smallerValues.get(0));
		Node current2 = head2;
		for (int i = 0; i<smallerValues.size(); i++) {
			current2.addToTail(smallerValues.get(i));
			current2 = current2.next;
		}
		
		
		for(int i = 0; i<largerValues.size(); i++) {
			current2.addToTail(largerValues.get(i));
			current2 = current2.next;
		}
		return head2;
	}
	
	public Node addReverseLists(Node listA, Node listB) {
		Node currentA = listA;
		Node currentB = listB;
		int numtocarry = 0;
		Node sum;
		if(currentA.value + currentB.value >=10) {
			sum = new Node(currentA.value + currentB.value -10);
			numtocarry = 1;
		}
		else {
			sum = new Node(currentA.value + currentB.value);
		}
		
		while(currentA.next != null || currentB.next != null) {
			
				sum.addToTail((currentA.next.value +currentB.next.value + numtocarry)%10);
				numtocarry = sum.next.value - (sum.next.value % 10);
				currentB = currentB.next;
				currentA = currentA.next;
				
			}
			
		
		return sum;
	}

	public static void main(String[] args) {
		Node list1 = new Node(5);
		list1.addToTail(6);

		Node list2 = new Node(4);
		list2.addToTail(3);
		list2.addToTail(7);

		displayList(list1);
		displayList(list2);

		list2.deleteNode(list2, 3);
		displayList(list2);
		

		
		Node list3 = new Node(4);
		list3.addToTail(4);
		list3.addToTail(3);
		list3.addToTail(3);
		list3.addToTail(5);
		list3.addToTail(5);
		list3.addToTail(4);
		list3.addToTail(4);
		list3.addToTail(7);
		list3.addToTail(4);
		list3.addToTail(4);

		displayList(list3);

		list2.deleteDuplicates(list3);
		displayList(list3);
		
		System.out.println(list3.getElementFromLast(4, list3));
		
		displayList(list3);
		list3.deleteFromMiddle(list3.next);
		displayList(list3);
		
		Node list4 = new Node(6);
		list4.addToTail(3);
		list4.addToTail(7);
		list4.addToTail(2);
		list4.addToTail(4);
		list4.addToTail(9);
		list4.addToTail(1);
		list4.addToTail(8);
		list4.addToTail(5);
		list4.addToTail(0);
		list4.addToTail(6);
		list4.addToTail(2);
		list4.addToTail(8);
		list4.addToTail(5);
		list4.addToTail(1);
		displayList(list4);
		displayList(list4.partitionList(list4, 6));
		
		Node list5 = new Node(7);
		list5.addToTail(1);
		list5.addToTail(6);
		list5.addToTail(4);
		displayList(list5);
		
		Node list6 = new Node(5);
		list6.addToTail(9);
		list6.addToTail(2);
		list6.addToTail(6);
		displayList(list6);
		
		displayList(list5.addReverseLists(list5, list6));
		
		
	}

}
